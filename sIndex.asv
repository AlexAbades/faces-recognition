function [Hap, Sad] = sIndex(X)
%SIND Creates a continuous strength index from the time responeses.
%   Detailed explanation goes here

% Delete unecessary info
X(:,2:end-1) = [];
% Obtain the real categories using the f_ext
X = realCateg(X);
% Split The Data into two tables, Happy and Sad, so we can make our
% strencgth index. 
Hap = X(ismember(X.RealCat, 'R-Happy'),:);
Sad = X(ismember(X.RealCat, 'R-Sad'),:);
% Delete unecesary columns
Hap(:,'RealCat') = [];
Sad(:,'RealCat') = [];

% Calculate sigma and standard deviations: Calculated with the happy and
% sad matrices. It can also be calculated as a hole. From X 
% Mean and std from Happy
Hap_mu = mean(Hap.mean);
Hap_std = std(Hap.mean);
% Add the columns to the table 
Hap.mu = ones(length(Hap.mean),1)*Hap_mu;
Hap.std = ones(length(Hap.mean),1)*Hap_std;
% Mean and std from Sad
Sad_mu = mean(Sad.mean);
Sad_std = std(Sad.mean);
% Add the columns to the table
Sad.mu = ones(length(Sad.mean),1)*Sad_mu;
Sad.std = ones(length(Sad.mean),1)*Sad_std;
% Change some labels for better understanding.
Hap.Properties.VariableNames = {'f_ext', 'time', 'mu', 'std'};
Sad.Properties.VariableNames = {'f_ext', 'time', 'mu', 'std'};

% Create a new column on each table class for the strngth indicator
Hap.sindex = zeros(length(Hap.time),1);
Sad.sindex = zeros(length(Sad.time),1);



for i = 1:length(Hap.time)
    if Hap{i,'time'} <  Hap_mu
        Hap.sindex(i) = 1;
    elseif (A{i,'time'} < 3*Hap_std && (A{i,'time'} > Hap_mu)
            A.sindex(i) = 1 - (A{i,'time'}/(3*Hap_sdt));
    elseif A{i,'time'} > 2*A{i, 'std'}
        A.sindex(i) = 0;
    else 
        A.sindex(i) = NaN;
    end 
end 






end

